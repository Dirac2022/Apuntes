# Trees, Binary Trees, and Binary Search Trees

A tree can be defined recursively as the following:
1. An empty structure is an empty tree.
2. If $t_1, ...,t_k$  are disjointed trees, then the structure whose root has as its children the roots of $t_1, ...,t_k$ is also a tree
3. Only structures generated by rules 1 and 2 are trees

- Each node has to be reachable from the root through a unique sequence of arcs, called a *path*. 
-  The *length of the path* is the number of arcs in a path
- The *level* of a node is the length of the path from the root to the node plus 1, which is the number of nodes in the path
- The *height* of a non empty tree is the maximum level of a node in the tree.
- The empty tree is a legitimate tree of height $0$, and a single node is a tree of height $1$.
- The level of a node must be between 1 (the level of the root) and the height of the tree, which in the extreme case is the level of the only leaf in a degenerate tree resembling a linked list.

Trees consisting in nodes and arcs: $\text{The number of arcs} = \text{The number of nodes} - 1$

#### Degenerate tree
A degenerate tree in data structures, also known as a pathological tree or a skewed tree, is a tree structure in which each parent node has only one associated child node, resulting in a tree that is essentially a linked list or a linear structure. In a degenerate tree, the tree's branching factor is effectively reduced to one, which means that it lacks the typical balance and structure of a well-organized tree.


![[Examples of trees.png]]


## Binary tree
A binary tree is a tree whose nodes have two children (possibly empty), and each child is designated as either a left child or a right child.


![[Types of binary trees.png]]
#### 1. Full Binary Tree
Is a Binary Tree in which every node has 0 or 2 children.
![[Valid-Invalid Full Binary Tree.png]]
#### 2. Complete binary tree
Has all levels completely filled with nodes except the last level and in the last level, all the nodes are as left side as possible.
![[Valid-Invalid Complete Binary Tree.png]]
	
#### 3. Perfect binary tree
All internal nodes have 2 children and all the leaf nodes are at the same depth or same level.
Is both full and complete.
![[Valid-Invalid Perfect Binary Tree.png]]
#### 4. Balanced binary tree
The height of the left and the right sub-trees of every node may differ by at most 1.
![[Valid-Invalid Balanced Binary Tree.png.png]]
### Note
According to Drozdek a *complete binary tree* is a tree whose nodes at all level have two non-null children, except for the last level. And  all leaves are at the same level. In other sources, trees with this conditions are referred to as *perfect binary trees*


In all binary tree there are at most $2^{i-1}$ nodes at level $i$. In a *perfect binary tree* at level $i$ there are $2^{i-1}$ nodes
### Proposition [Relation  between the number of leaves and nonterminal nodes]
For all  *full binary tree* the number of *leaves* $m$ is greater than number of *nonterminal nodes* $k$ and
$$m = k + 1$$
### Properties of Binary Trees

- $\text{{number of external nodes}} = \text{{number of internal nodes}} + 1$
- $\text{{number of nodes at level i}} \leq 2^{i-1}$
- $\text{numer of external nodes} \leq 2^{heigth}$
- $\text{heigth} \geq log_2 (\text{number of external nodes})$
- $\text{heigth} \geq log_2 (\text{number of nodes}) - 1$
- $\text{heigth} \leq ( \ \text{number of internal nodes}) - (\text{number of nodes} - 1  )/ 2$
- $\text{number of nodes} = 2^{height} - 1$
## Binary Search Tree

#### A property from Binary Search Trees or Ordered Binary Trees
For each node $n$ of the tree, all values stored in its left subtree (the tree whose root is the left child) are less than value $v$ stored in $n$, and all values stored in the right subtree are greater than $v$.

#### Non-Ordered Binary Trees
In this case, the order doesnÂ´t matter, so the following trees are identical
![[Identical Trees.png]]


<u>Multiple copies of the same value in the same tree is avoided.</u>

## Searching a Binary Search Tree
For every node, compare the key to be located with the value stored in the node currently referred. If the key is less than the value, go to the left subtree and try again. If it is greater than that value, try the right subtree. If it is the same, obviously the search can be discontinued. The search is also aborted if there is no way to go, indicating that the key is not in the tree.

**Search time depends of the height**
 - Maximum height (Degenerate tree) : $n$
 - Minimum height = $\text{ceiling(}log_2(n+1))$


# Insertion
To insert a new node with key $\textbf{el}$, a tree node with a dead end has to be reached, and the new node has to be attached to it. The key $\textbf{el}$ is compared to the key of a node currently being examined during a tree scan ($\textbf{p}$). If $\textbf{el}$ is less than that key, the left child (if any) of $\textbf{p}$ is tried; otherwise, the right child (if any) is tested. If the child of $\textbf{p}$ to be tested is empty, the scanning is discontinued and the new node becomes this child.

Inserting nodes into  binary search tree
![[Inserting nodes into a binary search tree.png]]


**The efficiency of insertions depends of the height of the tree**
- Best case (full tree - Drozdek) : $Olog_2(n) = \text{height of the tree}$
	![[Full Binary Tree - Drozdek.png]]
- Worse case (degenerate tree) : $Olog(n) = \text{height of the tree}$
	![[Degenerate Tree.png]]
# Tree traversal
Is the process of visiting each node in the tree exactly one time. We will focus on two ways of traversing a tree
### Breath-First Traversal
Is visiting each node staring from the lowest (or highest) level and moving down (or up) level by level, visiting nodes on each level from left to right  (or from right to left).
### Depth-First Traversal
Proceeds as far as possible to the left (or right), then backs up until the first crossroad, goes one step to the right (or left), and again as far as possible to the left (or right), repeating this process until all nodes are visited. 

There are three tasks of interest in this type of traversal:
	- **V** - Visiting a node
	- **L** - Traversing the left subtree
	- **R** - Traversing the right subtree

Three most common *depth-first traversal*
	- **VLR** - Preorder tree traversal
	- **LVR** - Inorder tree traversal
	- **LRV** - Postorder tree traversal

**The time complexity for tree traversal is $O(n)$**


# Deletion
The level of complexity in performing the operation depends on the position of the node to be deleted in the tree.

### 1. The node is a leaf
![[Deleting a leaf.png]]
### 2. The node has one child
![[Deleting a node with one child.png]]

### 3. The node has two children
We will discuss two different solutions to this problem
#### 3.1 Deletion by merging
This solution makes one tree out of the two subtrees of the node and then attaches it to the
nodes's parent. There are two ways:

- <u>Find in the left subtree the node with the greatest key</u> and make it a parent of the right subtree. The desired node is the rightmost node of the left subtree.

- <u>Find in the right subtree the node with the lowest key</u> and make it a parent of the left subtree. The desired node is the leftmost node of the right subtree.

	The height of a tree can be (a) extended or (b) reduced after deleting by mergingx
![[Deleting by merging.png]]

#### 3.2 Deletion by copying
The problem of deleting can be reduced to one of two simple cases, the node is a leaf or the node has only one nonempty child. This can be done by replacing the key being deleted with its immediate predecessor (or successor). Deletion by copying removes a key $k_1$ by overwriting it by another key $k_2$ and then removing the node that holds $k_2$.
This algorithm does not increase the height of the tree, but it still causes a problem if it is applied many times along with insertion. The algorithm is asymmetric; it  always deletes the node of the immediate predecessor of the key in node.


## Efficiency of deletions
- When the node to delete is a leaf: $O(n)$
- When the node to delete has one child: $O(n)$
- When the node to delete has two children: $O(log_2 n)$

### Notes
#### Predecessor of a key
Is the key in the rightmost node in the left subtree
#### Successor of a key
Is the key in the leftmost node in the right subtree


![[Summary of efficiency of tree operations.png]]



## Threaded Binary Tree

# Balancing a Tree

A binary tree is height-balanced or simply balanced if the difference in height of
both subtrees of any node in the tree is either zero or one

![[Balanced-NonBalanced Binary Trees.png]]

Analyzing the node $K$ in the three trees in the figure:
- <u>Analyzing the tree in (a)</u>
	The tree is balanced because each node satisfies the condition
- <u>Analyzing the tree in (b)</u>
	The node $K$ satisfies the condition, but the node $B$ does not, therefore the tree is unbalanced
- <u>Analyzing the tree in (b)</u>
	Each node excepts node $P$ and $R$ are unbalanced, therefore, the tree is unbalanced

**Balanced trees allow faster operations than unbalanced trees**

## AVL TREES
An AVL tree ) is one in which the height of the left and right subtrees of every node differ by at most one. Numbers in the nodes indicate the **balance factors** that are the differences between the heights of the left and right subtrees. A **balance factor** is the height of the right subtree minus the height of the left subtree.

![[Pasted image 20231214191225.png]]

**An AVL tree can become out of balance in four situations**, but only two of them need to be analyzed; the remaining two are symmetrical.

![[Pasted image 20231214194042.png]]

A node is inserted into the tree Figure 6.42a,  the resulting tree is shown in Figure 6.42b and in more detail in Figure 6.42c. To bring the tree back into balance, a double rotation is performed. The balance of the tree P is restored by rotating R about node Q (d) and then by rotating R again, this time about node P Figure 6.42e. 

P can be part of a larger AVL tree; it can be a child of some other node in the tree. If a node is
entered into the tree and the balance of P is disturbed and then restored, does extra work need to be done to the predecessor(s) of P? Fortunately not. Note that the height of the tree in Figure 6.42e resulting from the rotations are the same as the heights of the trees before insertion


# Heaps

A particular kind of binary tree, called a **heap**, has the following two properties:
	1. The value of each node is greater than or equal to the values stored in each of its
		children.
	2. The tree is perfectly balanced, and the leaves in the last level are all in the leftmost
		positions.
		
To be exact, these two properties define a **max heap**. If *greater* in the first property
is replaced with *less,* then the definition specifies a **min heap**. This means that
the root of a max heap contains the largest element, whereas the root of a min heap
contains the smallest.

A heap can be defined as an array *heap* of length $n$ in which
$$ \text{heap}[i] \geq heap[2 \cdot i + 1] \text{,  for } 0 \leq i < \dfrac{n-1}{n} $$
and
$$ \text{heap}[i] \geq heap[2 \cdot i + 2] \text{,  for } 0 \leq i < \dfrac{n-2}{n} $$

